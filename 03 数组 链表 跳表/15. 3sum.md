15. 3Sum

Medium

https://leetcode.com/problems/3sum/

Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

Notice that the solution set must not contain duplicate triplets.

 

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

 

**Constraints:**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



# 第一次

双指针

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        
        for (int t = 0; t < nums.length && nums[t] <= 0; t++) {
            if (t == 0 || nums[t - 1] != nums[t]) {
                int i = t + 1, j = nums.length - 1;
                while (i < j) {
                    int sum = nums[i] + nums[j] + nums[t];
                    if (sum < 0) {
                        i++;
                    } else if (sum > 0) {
                        j--;   
                    } else {
                        res.add(Arrays.asList(nums[t], nums[i++], nums[j--]));
                        while(i < j && nums[i] == nums[i - 1])
                            i++;
                        while(i < j && nums[j] == nums[j + 1])
                            j--;
                    }
                }     
            }
            
        }
        
        return res;
    }
}
```

**Algorithm**

The implementation is straightforward - we just need to modify `twoSumII` to produce triplets and skip repeating values.

1. For the main function:
   - Sort the input array `nums`.
   - Iterate through the array:
     - If the current value is greater than zero, break from the loop. Remaining values cannot sum to zero.
     - If the current value is the same as the one before, skip it.
     - Otherwise, call `twoSumII` for the current position `i`.
2. For `twoSumII` function:
   - Set the low pointer `lo` to `i + 1`, and high pointer `hi` to the last index.
   - While low pointer is smaller than high:
     - If `sum` of `nums[i] + nums[lo] + nums[hi]` is less than zero, increment `lo`.
     - If `sum` is greater than zero, decrement `hi`.
     - Otherwise, we found a triplet:
       - Add it to the result `res`.
       - Decrement `hi` and increment `lo`.
       - Increment `lo` while the next value is the same as before to avoid duplicates in the result.
3. Return the result `res`.

**Complexity Analysis**

- Time Complexity: O(*n*^2). `twoSumII` is O(*n*), and we call it n* times.

  Sorting the array takes O(*n*log*n*), so overall complexity is O(*n*log*n*+*n*^2). This is asymptotically equivalent to O(*n^*2).

- Space Complexity: from O(log*n*) to O(*n*), depending on the implementation of the sorting algorithm. For the purpose of complexity analysis, we ignore the memory required for the output.

